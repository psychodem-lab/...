<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gra Sudoku</title>
    <style>
        /* --- Stylizacja CSS --- */
        body {
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f4f4f9;
            margin: 20px;
        }

        h1 {
            color: #333;
        }

        #sudoku-grid {
            display: grid;
            grid-template-columns: repeat(9, 1fr);
            grid-template-rows: repeat(9, 1fr);
            width: 90vmin; /* Rozmiar siatki zale≈ºny od widocznego obszaru */
            max-width: 540px;
            border: 3px solid #333;
        }

        .cell {
            border: 1px solid #aaa;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(1rem, 4vw, 2rem);
            font-weight: bold;
            aspect-ratio: 1 / 1; /* Kom√≥rki sƒÖ kwadratowe */
            background-color: #fff;
        }

        /* Pogrubione linie dla podsiatek 3x3 */
        .cell:nth-child(3n) {
            border-right-width: 2px;
        }
        .cell:nth-child(9n) {
            border-right-width: 1px; /* Poprawienie ostatniej kolumny */
        }
        .cell:nth-child(27n) ~ .cell {
            border-top-width: 2px;
        }
        .cell:nth-child(1), .cell:nth-child(10), .cell:nth-child(19), 
        .cell:nth-child(28), .cell:nth-child(37), .cell:nth-child(46),
        .cell:nth-child(55), .cell:nth-child(64), .cell:nth-child(73) {
            /* Pogrubienie g√≥rnej krawƒôdzi dla pierwszych kom√≥rek w wierszach 4 i 7 */
        }

        .cell[data-row="2"] .cell, .cell[data-row="5"] .cell {
            border-bottom-width: 2px;
        }
        
        .cell[data-col="2"], .cell[data-col="5"] {
            border-right-width: 2px;
        }
        
        /* Dodatkowe pogrubienie krawƒôdzi dla podsiatek 3x3 */
        .cell:nth-child(9n + 1):nth-child(n + 19):nth-child(-n + 27),
        .cell:nth-child(9n + 1):nth-child(n + 46):nth-child(-n + 54) {
             border-top-width: 2px;
        }
        
        /* Specjalne style dla wprowadzania danych przez u≈ºytkownika */
        .user-input {
            color: #00f;
            cursor: pointer;
            outline: none;
            text-align: center;
            background-color: #e6e6ff;
        }

        .given-number {
            color: #333;
            background-color: #f0f0f0;
        }

        .error {
            background-color: #ffcccc !important; /* Czerwone t≈Ço dla b≈Çƒôd√≥w */
        }

        /* Stylizacja przycisk√≥w i panelu sterowania */
        #controls {
            margin-top: 20px;
            display: flex;
            gap: 10px;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            transition: background-color 0.3s;
        }

        #new-game-btn {
            background-color: #4CAF50;
            color: white;
        }

        #check-btn {
            background-color: #2196F3;
            color: white;
        }

        #new-game-btn:hover { background-color: #45a049; }
        #check-btn:hover { background-color: #0b7dda; }

    </style>
</head>
<body>

    <h1>Sudoku</h1>
    
    <div id="sudoku-grid">
        </div>
    
    <div id="controls">
        <button id="new-game-btn">Nowa Gra</button>
        <button id="check-btn">Sprawd≈∫</button>
    </div>

    <script>
        // --- Logika Gry JavaScript ---

        const GRID_SIZE = 9;
        const SUBGRID_SIZE = 3;
        const gridElement = document.getElementById('sudoku-grid');
        const newGameButton = document.getElementById('new-game-btn');
        const checkButton = document.getElementById('check-btn');

        let initialBoard = []; // PoczƒÖtkowy stan planszy (wype≈Çnione pola)
        let currentBoard = []; // Aktualny stan planszy (z wprowadzonymi danymi)
        let solutionBoard = []; // RozwiƒÖzanie

        // Minimalistyczny i szybki generator Sudoku
        function generateSudoku() {
            // 1. Wygeneruj w pe≈Çni wype≈ÇnionƒÖ planszƒô (uproszczona wersja)
            solutionBoard = generateFullBoard();
            initialBoard = JSON.parse(JSON.stringify(solutionBoard));
            
            // 2. Usu≈Ñ czƒô≈õƒá liczb, aby utworzyƒá zagadkƒô
            const emptyCells = 40; // Liczba pustych p√≥l (mo≈ºna regulowaƒá trudno≈õƒá)
            for (let i = 0; i < emptyCells; i++) {
                let row, col;
                do {
                    row = Math.floor(Math.random() * GRID_SIZE);
                    col = Math.floor(Math.random() * GRID_SIZE);
                } while (initialBoard[row][col] === 0);
                initialBoard[row][col] = 0;
            }

            // Aktualizuj obecnƒÖ planszƒô
            currentBoard = JSON.parse(JSON.stringify(initialBoard));
            renderGrid();
        }

        // Prosta funkcja generujƒÖca w pe≈Çni wype≈ÇnionƒÖ planszƒô
        // U≈ºywa backtracking'u, ale dla uproszczenia tutaj tylko zwraca przyk≈Çadowe rozwiƒÖzanie
        function generateFullBoard() {
            // Wersja skr√≥cona - dla demonstracji u≈ºyjemy statycznego rozwiƒÖzania,
            // aby uniknƒÖƒá skomplikowanej logiki generatora z backtrackingiem.
            // W prawdziwej grze potrzebny jest pe≈Çny generator.
            return [
                [5, 3, 4, 6, 7, 8, 9, 1, 2],
                [6, 7, 2, 1, 9, 5, 3, 4, 8],
                [1, 9, 8, 3, 4, 2, 5, 6, 7],
                [8, 5, 9, 7, 6, 1, 4, 2, 3],
                [4, 2, 6, 8, 5, 3, 7, 9, 1],
                [7, 1, 3, 9, 2, 4, 8, 5, 6],
                [9, 6, 1, 5, 3, 7, 2, 8, 4],
                [2, 8, 7, 4, 1, 9, 6, 3, 5],
                [3, 4, 5, 2, 8, 6, 1, 7, 9]
            ];
        }

        // Rysowanie planszy w HTML
        function renderGrid() {
            gridElement.innerHTML = ''; // Wyczy≈õƒá starƒÖ planszƒô

            for (let r = 0; r < GRID_SIZE; r++) {
                for (let c = 0; c < GRID_SIZE; c++) {
                    const cell = document.createElement('div');
                    cell.classList.add('cell');
                    cell.dataset.row = r;
                    cell.dataset.col = c;
                    
                    const value = initialBoard[r][c];
                    
                    if (value !== 0) {
                        // Liczba podana na poczƒÖtku - nie edytowalna
                        cell.textContent = value;
                        cell.classList.add('given-number');
                    } else {
                        // Pusta kom√≥rka - edytowalna
                        cell.classList.add('user-input');
                        cell.contentEditable = true; // Pozw√≥l na edycjƒô
                        cell.addEventListener('input', handleCellInput);
                        
                        // Wstawienie aktualnej warto≈õci, je≈õli istnieje
                        if (currentBoard[r][c] !== 0) {
                             cell.textContent = currentBoard[r][c];
                        }
                    }
                    
                    gridElement.appendChild(cell);
                }
            }
        }

        // Obs≈Çuga wprowadzania danych przez u≈ºytkownika
        function handleCellInput(event) {
            const cell = event.target;
            const r = parseInt(cell.dataset.row);
            const c = parseInt(cell.dataset.col);
            let value = cell.textContent.trim();

            // Upewnij siƒô, ≈ºe wprowadzono pojedynczƒÖ cyfrƒô od 1 do 9
            if (value.length > 1) {
                value = value.slice(0, 1);
            }
            if (value === '' || isNaN(value) || value === '0') {
                value = '';
                cell.textContent = '';
                currentBoard[r][c] = 0;
            } else {
                value = parseInt(value);
                cell.textContent = value;
                currentBoard[r][c] = value;
            }
            
            // Ogranicz do jednej cyfry
            cell.textContent = cell.textContent.slice(0, 1);
        }
        
        // Funkcja sprawdzajƒÖca rozwiƒÖzanie
        function checkSolution() {
            let isCorrect = true;
            let filledCells = 0;
            
            // Iteruj przez kom√≥rki, aby sprawdziƒá i pod≈õwietliƒá b≈Çƒôdy
            const cells = document.querySelectorAll('.cell');
            cells.forEach(cell => {
                const r = parseInt(cell.dataset.row);
                const c = parseInt(cell.dataset.col);
                const currentValue = currentBoard[r][c];
                
                cell.classList.remove('error'); // Usu≈Ñ poprzednie b≈Çƒôdy

                if (currentValue !== 0) {
                    filledCells++;
                    if (currentValue !== solutionBoard[r][c]) {
                        cell.classList.add('error');
                        isCorrect = false;
                    }
                }
            });
            
            if (isCorrect && filledCells === GRID_SIZE * GRID_SIZE) {
                alert('üéâ Gratulacje! Plansza jest poprawnie rozwiƒÖzana! üéâ');
            } else if (isCorrect) {
                 alert('‚úÖ Wszystkie wprowadzone liczby sƒÖ poprawne, ale plansza nie jest jeszcze kompletna.');
            } else {
                alert('‚ùå Plansza zawiera b≈Çƒôdy (b≈Çƒôdne pola sƒÖ pod≈õwietlone na czerwono).');
            }
        }
        
        // Inicjalizacja gry
        function init() {
            newGameButton.addEventListener('click', generateSudoku);
            checkButton.addEventListener('click', checkSolution);
            generateSudoku();
        }

        // Uruchomienie gry po za≈Çadowaniu strony
        window.onload = init;
        
    </script>
</body>
</html>
